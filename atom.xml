<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨俊浩的个人主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hao1004.github.io/"/>
  <updated>2021-01-08T01:34:18.214Z</updated>
  <id>https://hao1004.github.io/</id>
  
  <author>
    <name>杨俊浩</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录vue前端项目升级的做法</title>
    <link href="https://hao1004.github.io/2021/01/07/%E8%AE%B0%E5%BD%95vue%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E7%9A%84%E5%81%9A%E6%B3%95/"/>
    <id>https://hao1004.github.io/2021/01/07/%E8%AE%B0%E5%BD%95vue%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E7%9A%84%E5%81%9A%E6%B3%95/</id>
    <published>2021-01-07T12:51:08.000Z</published>
    <updated>2021-01-08T01:34:18.214Z</updated>
    
    <content type="html"><![CDATA[<h4 id="升级项目脚手架至最新的-vue-cli"><a href="#升级项目脚手架至最新的-vue-cli" class="headerlink" title="升级项目脚手架至最新的 vue-cli"></a><font color="4964C7">升级项目脚手架至最新的 vue-cli</font></h4><ul><li>建议使用 npm 或者 vue ui 下载最新的 vue-cli，然后从旧项目的入口文件<code>main.js</code>入手，理清引入的模块，然后才将相关目录以及 nodo 依赖逐步引入新的脚手架，最后再去检查旧项目的构建配置，并移植到新的脚手架配置文件当中，完成升级。<br></li></ul><h4 id="引入-eslint-校验工具"><a href="#引入-eslint-校验工具" class="headerlink" title="引入 eslint 校验工具"></a><font color="4964C7">引入 eslint 校验工具</font></h4><ul><li>很多旧项目，在创建初始并没有使用 eslint 去校验和修正代码，因此往往会导致代码风格混乱并且不规范。这里总结下在旧项目下使用 eslint 的做法。引入 eslint 参考 vue-cli 官网提供的做法，规范风格也根据项目需求自由选择，引入后再去<code>配置 vscode 进行自动校验和修复</code>，vscode 的自动修复可以解决部分代码格式问题，之后要<code>在.eslintignore 文件下忽略旧项目的文件</code>，这里建议一开始把所有目录都忽略了，然后先对公共的 js 文件目录(如 api，utils，filters，router，directive)进行一一的校验和修正，不规范的 views 目录下的文件，在以后业务需求涉及（或者安排时间全局调整）才去取消忽略，专门修复，以此逐步的将项目代码规范化。<br></li></ul><h4 id="需要后端配合的优化"><a href="#需要后端配合的优化" class="headerlink" title="需要后端配合的优化"></a><font color="4964C7">需要后端配合的优化</font></h4><ul><li><p>确认是否开启 gzip；</p></li><li><p>有没配置好 http 缓存相关字段；</p></li><li><p>js 库及插件配合 webpack 的配置，不打包进源文件，将相关静态资源放置到 cdn；</p></li><li><p>提醒后端使用 http2 协议；</p><br></li></ul><h4 id="其他细节优化点"><a href="#其他细节优化点" class="headerlink" title="其他细节优化点"></a><font color="4964C7">其他细节优化点</font></h4><ul><li><p>根据 vue-cli 提供的打包后的文件报告，查看是否有视图引入不合理的模块，导致文件过大，从而进行相关优化，移除或替换不合理的模块，或者重构某些过大的视图</p></li><li><p>对公共模块进行优化处理，发现冗余的模块要做拆分处理，经常重复的代码则考虑模块化</p></li><li><p>完善 README.md 文件，细节充分的说明文档，能有效减轻项目交接或者新人接手的成本</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;升级项目脚手架至最新的-vue-cli&quot;&gt;&lt;a href=&quot;#升级项目脚手架至最新的-vue-cli&quot; class=&quot;headerlink&quot; title=&quot;升级项目脚手架至最新的 vue-cli&quot;&gt;&lt;/a&gt;&lt;font color=&quot;4964C7&quot;&gt;升级项目脚手架至
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue开发规范</title>
    <link href="https://hao1004.github.io/2020/12/24/Vue%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://hao1004.github.io/2020/12/24/Vue%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2020-12-24T11:01:48.000Z</published>
    <updated>2020-12-24T11:02:42.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端开发规范"><a href="#前端开发规范" class="headerlink" title="前端开发规范"></a>前端开发规范</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Vue 项目规范以 👉 <a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">Vue 官方规范</a> 中的规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。</p><blockquote><p>*请仔细阅读 Vue 官方规范，切记，此为第一步。目标是不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的*</p></blockquote><br><h2 id="二、环境要求"><a href="#二、环境要求" class="headerlink" title="二、环境要求"></a>二、环境要求</h2><p>1.Node.js 8.9 或更高版本，你可以使用 nvm 或 nvm-windows 在一台电脑中管理多个 Node 版本</p><p>2.使用 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code (VS Code)</a> 进行代码编写</p><p>3.代码提交前使用 VS Code 进行格式化（不要格式引入的外部文件）</p><p>4.规定 Tab 大小为 <code>2 个空格</code>，保证在所有环境下获得一致展现</p><p>5.安装插件 <a href="https://marketplace.visualstudio.com/items?itemName=octref.vetur" target="_blank" rel="noopener">Vetur</a>（ Vue 开发扩展及 Vue 文件代码格式化）</p><p>6.使用 Chrome 浏览器并安装 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener">Vue.js devtools</a> 进行调试</p><br><h2 id="三、编码规范"><a href="#三、编码规范" class="headerlink" title="三、编码规范"></a>三、编码规范</h2><h3 id="Vue-组件编码规范"><a href="#Vue-组件编码规范" class="headerlink" title="Vue 组件编码规范"></a>Vue 组件编码规范</h3><h4 id="组件规范"><a href="#组件规范" class="headerlink" title="组件规范"></a>组件规范</h4><blockquote><p>1.组件名为多个单词。</p></blockquote><p>组件名应该始终是多个单词组成（大于等于 2），且命名规范为 KebabCase 格式。<br>这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'TodoItem'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Todo'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'todo-item'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.组件文件名为 pascal-case 格式</p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- my-component.vue</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- myComponent.vue</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure><blockquote><p>3.基础组件文件名为 base 开头，使用完整单词而不是缩写。</p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- base-button.vue</span><br><span class="line">|- base-table.vue</span><br><span class="line">|- base-icon.vue</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyButton.vue</span><br><span class="line">|- VueTable.vue</span><br><span class="line">|- Icon.vue</span><br></pre></td></tr></table></figure><blockquote><p>4.和父组件紧密耦合的子组件应该以父组件名作为前缀命名</p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- todo-list.vue</span><br><span class="line">|- todo-list-item.vue</span><br><span class="line">|- todo-list-item-button.vue</span><br><span class="line">|- user-profile-options.vue （完整单词）</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoItem.vue</span><br><span class="line">|- TodoButton.vue</span><br><span class="line">|- UProfOpts.vue （使用了缩写）</span><br></pre></td></tr></table></figure><blockquote><p>5.模板中组件名为 pascal-case 格式<code>（注：当前项目自定义标签不推荐使用自闭合组件）</code></p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在所有地方 --&gt;</span><br><span class="line">&lt;my-component&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mycomponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">mycomponent</span>&gt;</span></span></span><br><span class="line">&lt;MyComponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br><span class="line">&lt;MyComponent /&gt;</span><br></pre></td></tr></table></figure><blockquote><p>6.组件的 data 必须是一个函数</p></blockquote><p>当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。<br>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">'jack'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'jack'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>7.Prop 定义应该尽量详细</p></blockquote><ul><li>必须使用 camelCase 驼峰命名</li><li>必须指定类型</li><li>必须加上 required 或者 default，两者二选其一</li><li>建议加上注释，表明其含义</li><li>如果有业务需要，必须加上 validator 验证</li></ul><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> props: &#123;</span><br><span class="line">  <span class="comment">// 组件状态，用于控制组件的颜色</span></span><br><span class="line">   status: &#123;</span><br><span class="line">     type: <span class="built_in">String</span>,</span><br><span class="line">     required: <span class="literal">true</span>,</span><br><span class="line">     validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> [</span><br><span class="line">         <span class="string">'succ'</span>,</span><br><span class="line">         <span class="string">'info'</span>,</span><br><span class="line">         <span class="string">'error'</span></span><br><span class="line">       ].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">    <span class="comment">// 用户级别，用于显示皇冠个数</span></span><br><span class="line">   userLevel：&#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样做只有开发原型系统时可以接受</span></span><br><span class="line">props: [<span class="string">'status'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>8.为组件样式设置作用域</p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-close"</span>&gt;X&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用 <span class="string">`scoped`</span> 特性 --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-close"</span>&gt;X&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;!-- 没有使用 <span class="string">`scoped`</span> 特性 --&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .btn-close &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>9 如果特性元素较多，应该主动换行<code>（注：该操作能交给vscode自动格式化处理）</code></p></blockquote><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  foo=<span class="string">"a"</span></span><br><span class="line">  bar=<span class="string">"b"</span></span><br><span class="line">  baz=<span class="string">"c"</span></span><br><span class="line">  foo=<span class="string">"a"</span></span><br><span class="line">  bar=<span class="string">"b"</span></span><br><span class="line">  baz=<span class="string">"c"</span></span><br><span class="line">  foo=<span class="string">"a"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component foo=<span class="string">"a"</span> bar=<span class="string">"b"</span> baz=<span class="string">"c"</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="模板中使用简单的表达式"><a href="#模板中使用简单的表达式" class="headerlink" title="模板中使用简单的表达式"></a>模板中使用简单的表达式</h4><p>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。</p><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedFullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.fullName.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;).join(<span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">       &#123;&#123;</span><br><span class="line">          fullName.split(<span class="string">' '</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> word[<span class="number">0</span>].toUpperCase() + word.slice(<span class="number">1</span>)</span><br><span class="line">           &#125;).join(<span class="string">' '</span>)</span><br><span class="line">        &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure><h4 id="指令推荐都使用缩写形式，-用-表示-v-bind-、用-表示-v-on-和用-表示-v-slot"><a href="#指令推荐都使用缩写形式，-用-表示-v-bind-、用-表示-v-on-和用-表示-v-slot" class="headerlink" title="指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)"></a>指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)</h4><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  @input=<span class="string">"onInput"</span></span><br><span class="line">  :value=<span class="string">"newTodoText"</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;template #header&gt;</span><br><span class="line">  &lt;h1&gt;Here might be a page title&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-on:input=<span class="string">"onInput"</span></span><br><span class="line">  v-bind:value=<span class="string">"newTodoText"</span></span><br><span class="line">&gt;</span><br><span class="line">&lt;template v-slot:header&gt;</span><br><span class="line">  &lt;h1&gt;Here might be a page title&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure><h4 id="标签顺序保持一致"><a href="#标签顺序保持一致" class="headerlink" title="标签顺序保持一致"></a>标签顺序保持一致</h4><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;...&lt;/</span>script&gt;</span><br><span class="line">&lt;style&gt;...&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;...&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;style&gt;...&lt;/</span>style&gt;</span><br><span class="line">&lt;script&gt;...&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-for-和-v-if-要注意的点"><a href="#v-for-和-v-if-要注意的点" class="headerlink" title="v-for 和 v-if 要注意的点"></a>v-for 和 v-if 要注意的点</h4><blockquote><p>1.必须为 v-for 设置键值 key</p></blockquote><p>在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。</p><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span></span><br><span class="line">    :key=<span class="string">"todo.id"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span>&gt;</span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><blockquote><p>2.永远不要把 v-if 和 v-for 同时用在同一个元素上</p></blockquote><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li><p>为了过滤一个列表中的项目 (比如 v-for=”user in users” v-if=”user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</p></li><li><p>为了避免渲染本应该被隐藏的列表 (比如 v-for=”user in users” v-if=”shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。</p></li></ul><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in activeUsers"</span></span><br><span class="line">    :key=<span class="string">"user.id"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.users.filter(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span> v-<span class="keyword">if</span>=<span class="string">"shouldShowUsers"</span>&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in users"</span></span><br><span class="line">    :key=<span class="string">"user.id"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user<span class="selector-class">.name</span> &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in users"</span></span><br><span class="line">    v-<span class="keyword">if</span>=<span class="string">"user.isActive"</span></span><br><span class="line">    :key=<span class="string">"user.id"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">"user in users"</span></span><br><span class="line">    v-<span class="keyword">if</span>=<span class="string">"shouldShowUsers"</span></span><br><span class="line">    :key=<span class="string">"user.id"</span></span><br><span class="line">  &gt;</span><br><span class="line">    &#123;&#123; user<span class="selector-class">.name</span> &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><blockquote><p>3.如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个&lt;div&gt;元素)</p></blockquote><p>默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。</p><p>正例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  v-<span class="keyword">if</span>=<span class="string">"error"</span></span><br><span class="line">  key=<span class="string">"search-status"</span></span><br><span class="line">&gt;</span><br><span class="line">  错误：&#123;&#123; error &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div</span></span><br><span class="line"><span class="regexp">  v-else</span></span><br><span class="line"><span class="regexp">  key="search-results"</span></span><br><span class="line"><span class="regexp">&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; results &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>反例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">"error"</span>&gt;</span><br><span class="line">  错误：&#123;&#123; error &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">  &#123;&#123; results &#125;&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>4.v-show 与 v-if 选择</p></blockquote><p>如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。</p><h4 id="script-标签内部结构顺序"><a href="#script-标签内部结构顺序" class="headerlink" title="script 标签内部结构顺序"></a>script 标签内部结构顺序</h4><p>name &gt; components &gt; mixins &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods</p><h4 id="Vue-Router-规范"><a href="#Vue-Router-规范" class="headerlink" title="Vue Router 规范"></a>Vue Router 规范</h4><blockquote><p>页面跳转数据传递使用路由参数</p></blockquote><p>页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="string">'123'</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'userCenter'</span>, <span class="attr">query</span>: &#123; <span class="attr">id</span>: id &#125; &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>使用路由懒加载（延迟加载）机制</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/uploadAttachment'</span>,</span><br><span class="line">  name: <span class="string">'uploadAttachment'</span>,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    title: <span class="string">'上传附件'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/view/components/uploadAttachment/index.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>router 中的命名规范</p></blockquote><p>path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）</p><p>name 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/reload/smart-reload-list'</span>,</span><br><span class="line">        name: <span class="string">'SmartReloadList'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">          title: <span class="string">'SmartReload'</span>,</span><br><span class="line">          childrenPoints: [</span><br><span class="line">            &#123;</span><br><span class="line">              title: <span class="string">'查询'</span>,</span><br><span class="line">              name: <span class="string">'smart-reload-search'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: <span class="string">'执行reload'</span>,</span><br><span class="line">              name: <span class="string">'smart-reload-update'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              title: <span class="string">'查看执行结果'</span>,</span><br><span class="line">              name: <span class="string">'smart-reload-result'</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">          <span class="keyword">import</span>(<span class="string">'@/views/reload/smart-reload/smart-reload-list.vue'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><blockquote><p>router 中的 path 命名规范</p></blockquote><p>path 除了采用 kebab-case 命名规范以外，必须以 / 开头，即使是 children 里的 path 也要以 / 开头。</p><p>经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以/开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/file'</span>,</span><br><span class="line">  name: <span class="string">'File'</span>,</span><br><span class="line">  component: Main,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    title: <span class="string">'文件服务'</span>,</span><br><span class="line">    icon: <span class="string">'ios-cloud-upload'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/file/file-list'</span>,</span><br><span class="line">      name: <span class="string">'FileList'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/file/file-list.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/file/file-add'</span>,</span><br><span class="line">      name: <span class="string">'FileAdd'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/file/file-add.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/file/file-update'</span>,</span><br><span class="line">      name: <span class="string">'FileUpdate'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/file/file-update.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Vue-项目目录规范"><a href="#Vue-项目目录规范" class="headerlink" title="Vue 项目目录规范"></a>Vue 项目目录规范</h3><blockquote><p>基础</p></blockquote><p>vue 项目中的所有命名尽量与后端命名统一。</p><p>比如权限：后端 privilege, 前端无论 router , store, api 等都使用 privielege 单词</p><blockquote><p>使用 Vue-cli 脚手架</p></blockquote><p>永远使用最新的 vue-cli 来初始化项目，项目名按照上面的命名规范。</p><blockquote><p>目录说明</p></blockquote><p>目录名按照上面的命名规范，以 kebab-case 方式命名为主。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">src                               源码目录</span><br><span class="line">|-- api                              所有api接口</span><br><span class="line">|-- assets                           静态资源，images, icons, styles等</span><br><span class="line">|-- components                       公用组件</span><br><span class="line">|-- config                           配置信息</span><br><span class="line">|-- constants                        常量信息，项目所有Enum, 全局常量等</span><br><span class="line">|-- directives                       自定义指令</span><br><span class="line">|-- filters                          过滤器，全局工具</span><br><span class="line">|-- datas                            模拟数据，临时存放</span><br><span class="line">|-- lib                              外部引用的插件存放及修改文件</span><br><span class="line">|-- mock                             模拟接口，临时存放</span><br><span class="line">|-- plugins                          插件，全局使用</span><br><span class="line">|-- router                           路由，统一管理</span><br><span class="line">|-- store                            vuex, 统一管理</span><br><span class="line">|-- themes                           自定义样式主题</span><br><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块</span><br><span class="line">|   |-- |-- role-list.vue                    role列表页面</span><br><span class="line">|   |-- |-- role-add.vue                     role新建页面</span><br><span class="line">|   |-- |-- role-update.vue                  role更新页面</span><br><span class="line">|   |-- |-- common.scss                      role模块样式</span><br><span class="line">|   |-- |-- constants                        role模块通用常量文件夹</span><br><span class="line">|   |-- |-- components                       role模块通用组件文件夹</span><br><span class="line">|   |-- reviewer                         reviewer模块</span><br></pre></td></tr></table></figure><blockquote><p>api 目录</p></blockquote><ul><li>文件、变量命名要与后端保持一致。</li><li>此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。</li><li>api 中的方法名字要与后端 api url 尽量保持语义高度一致性。</li><li>对于 api 中的每个方法要添加注释，注释与后端接口文档保持一致。</li></ul><p>后端 url： RoleController.java</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// post请求:</span><br><span class="line"></span><br><span class="line">/<span class="keyword">role</span>/<span class="keyword">add</span></span><br><span class="line">/<span class="keyword">role</span>/<span class="keyword">update</span></span><br><span class="line">/<span class="keyword">role</span>/<span class="keyword">delete</span></span><br><span class="line"></span><br><span class="line">// <span class="keyword">get</span>请求:</span><br><span class="line"></span><br><span class="line">/<span class="keyword">role</span>/<span class="keyword">info</span>/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>前端： employee.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加角色</span></span><br><span class="line">postRoleAdd: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> postAxios(<span class="string">'/role/add'</span>, data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 更新角色</span></span><br><span class="line">postRoleUpdate: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> postAxios(<span class="string">'/role/update'</span>, data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 删除角色</span></span><br><span class="line">postRoleDelete: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> postAxios(<span class="string">'/role/delete'</span>, data)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 获取角色信息</span></span><br><span class="line">getRoleInfo: <span class="function">(<span class="params">roleId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getAxios(<span class="string">'/role/info/'</span> + roleId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>assets 目录</p></blockquote><p>assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|assets</span><br><span class="line">|-- icons</span><br><span class="line">|-- images</span><br><span class="line">|   |-- background-color.png</span><br><span class="line">|   |-- upload-header.png</span><br><span class="line">|-- styles</span><br></pre></td></tr></table></figure><blockquote><p>components 目录</p></blockquote><p>此目录应按照组件进行目录划分，目录命名为 kebab-case，组件命名规则也为 kebab-case</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|components</span><br><span class="line">|-- error-log</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.less</span><br><span class="line">|-- markdown-editor</span><br><span class="line">|   |-- index.vue</span><br><span class="line">|   |-- index.js</span><br><span class="line">|-- kebab-<span class="keyword">case</span></span><br></pre></td></tr></table></figure><blockquote><p>constants 目录</p></blockquote><p>此目录存放项目所有常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|constants</span><br><span class="line">|-- index.js</span><br><span class="line">|-- role.js</span><br></pre></td></tr></table></figure><p>例子：report.js</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间类型</span></span><br><span class="line">export const timeTypeArr = [</span><br><span class="line">  &#123; <span class="string">command:</span> <span class="number">0</span>, <span class="string">name:</span> <span class="string">'评论时间'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">command:</span> <span class="number">1</span>, <span class="string">name:</span> <span class="string">'统计时间'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">command:</span> <span class="number">2</span>, <span class="string">name:</span> <span class="string">'客人修改时间'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">command:</span> <span class="number">3</span>, <span class="string">name:</span> <span class="string">'week'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 星级变动类型</span></span><br><span class="line">export const starTypeArr = [</span><br><span class="line">  &#123; <span class="string">value:</span> <span class="number">0</span>, <span class="string">label:</span> <span class="string">'新增'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">value:</span> <span class="number">1</span>, <span class="string">label:</span> <span class="string">'星级变好'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">value:</span> <span class="number">2</span>, <span class="string">label:</span> <span class="string">'星级变差'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">value:</span> <span class="number">3</span>, <span class="string">label:</span> <span class="string">'差评消失'</span> &#125;,</span><br><span class="line">  &#123; <span class="string">value:</span> <span class="number">4</span>, <span class="string">label:</span> <span class="string">'好评消失'</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>router 与 store 目录</p></blockquote><ul><li><p>这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。</p></li><li><p>router 尽量按照 views 中的结构保持一致</p></li><li><p>store 按照业务进行拆分不同的 js 文件</p></li></ul><blockquote><p>views 目录</p></blockquote><ul><li>命名要与后端、router、api 等保持一致</li><li>components 中组件要使用 pascal-case 规则</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|-- views                            视图目录</span><br><span class="line">|   |-- role                             role模块名</span><br><span class="line">|   |   |-- role-list.vue                    role列表页面</span><br><span class="line">|   |   |-- role-add.vue                     role新建页面</span><br><span class="line">|   |   |-- role-update.vue                  role更新页面</span><br><span class="line">|   |   |-- common.scss                      role模块样式</span><br><span class="line">|   |   |-- components                      role模块通用组件文件夹</span><br><span class="line">|   |   |   |-- role-header.vue                        role头部组件</span><br><span class="line">|   |   |   |-- role-modal.vue                         role弹出框组件</span><br><span class="line">|   |-- reviewer                         reviewer模块</span><br></pre></td></tr></table></figure><blockquote><p>注释说明</p></blockquote><p>整理必须加注释的地方</p><ul><li>公共组件使用说明</li><li>api 目录的接口 js 文件必须加注释</li><li>store 中的 state, mutation, action 等必须加注释</li><li>vue 文件中的 template 必须加注释，若文件较大添加 start end 注释</li><li>vue 文件的 methods，每个 method 必须添加注释</li><li>vue 文件的 data, 非常见单词要加注释</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><blockquote><p>不要复制链贴代码</p></blockquote><ul><li><p>不同组件之间能共用的代码或者模块，除非万不得已才选择复制，否则都应该封装成通用的模块文件，代码模块化要以复用性/拆分逻辑为原则</p></li><li><p>使用别人的代码也是一样，应尽量先理解他人的思路再去使用，而不是简单的复制链贴，这样才便于后续维护及根据业务调整</p></li></ul><blockquote><p>尽量不要手动操作 DOM</p></blockquote><ul><li>因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。</li></ul><blockquote><p>删除无用代码</p></blockquote><ul><li>因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码、无用的注释。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端开发规范&quot;&gt;&lt;a href=&quot;#前端开发规范&quot; class=&quot;headerlink&quot; title=&quot;前端开发规范&quot;&gt;&lt;/a&gt;前端开发规范&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用的工具函数</title>
    <link href="https://hao1004.github.io/2020/01/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <id>https://hao1004.github.io/2020/01/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</id>
    <published>2020-01-07T12:50:24.000Z</published>
    <updated>2021-01-08T01:35:34.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="获取值的类型"><a href="#获取值的类型" class="headerlink" title="获取值的类型"></a><font color="4964C7">获取值的类型</font></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generateArray</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(+end + <span class="number">1</span>).keys()).slice(+start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><font color="4964C7">深拷贝</font></h4><p>接受普通对象/数组，对时间和正则对象进行复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getValueType(source) !== <span class="string">'Object'</span> &amp;&amp; getValueType(source) !== <span class="string">'Array'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error arguments'</span>, <span class="string">'shallowClone'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> targetObj = getValueType(source) === <span class="string">'Array'</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> keys <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getValueType(source) === <span class="string">'Date'</span>) &#123;</span><br><span class="line">      targetObj[keys] = <span class="keyword">new</span> <span class="built_in">Date</span>(source[keys].valueOf());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getValueType(source) === <span class="string">'RegExp'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> reg = source[keys];</span><br><span class="line">      <span class="keyword">const</span> pattern = reg.valueOf();</span><br><span class="line">      <span class="keyword">const</span> flagMap = &#123; <span class="attr">global</span>: <span class="string">'g'</span>, <span class="attr">ignoreCase</span>: <span class="string">'i'</span>, <span class="attr">multiline</span>: <span class="string">'m'</span> &#125;;</span><br><span class="line">      <span class="keyword">const</span> flags = <span class="built_in">Object</span>.keys(flagMap).reduce(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">        acc += reg[key] ? flagMap[key] : <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">      &#125;, <span class="string">''</span>);</span><br><span class="line">      targetObj[keys] = <span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern.source, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getValueType(source[keys]) === <span class="string">'Object'</span> || getValueType(source[keys]) === <span class="string">'Array'</span>) &#123;</span><br><span class="line">      targetObj[keys] = deepClone(source[keys]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      targetObj[keys] = source[keys];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换时间格式"><a href="#转换时间格式" class="headerlink" title="转换时间格式"></a><font color="4964C7">转换时间格式</font></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">dateFormat</span> = (<span class="params">time, fmt = <span class="string">'yyyy-MM-dd hh:mm'</span></span>) =&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> time === <span class="string">'object'</span>) &#123;</span><br><span class="line">    date = time;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="string">''</span> + time).length === <span class="number">10</span>) time = <span class="built_in">parseInt</span>(time, <span class="number">10</span>) * <span class="number">1000</span>;</span><br><span class="line">    date = <span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt)) &#123;</span><br><span class="line">    fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (date.getFullYear() + <span class="string">''</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="string">'M+'</span>: date.getMonth() + <span class="number">1</span>,</span><br><span class="line">    <span class="string">'d+'</span>: date.getDate(),</span><br><span class="line">    <span class="string">'h+'</span>: date.getHours(),</span><br><span class="line">    <span class="string">'m+'</span>: date.getMinutes(),</span><br><span class="line">    <span class="string">'s+'</span>: date.getSeconds()</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(<span class="subst">$&#123;k&#125;</span>)`</span>).test(fmt)) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = o[k] + <span class="string">''</span>;</span><br><span class="line">      fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="built_in">RegExp</span>.$<span class="number">1.</span>length === <span class="number">1</span> ? str : padLeftZero(str));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeftZero</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">'00'</span> + str).substr(str.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤对象空属性"><a href="#过滤对象空属性" class="headerlink" title="过滤对象空属性"></a><font color="4964C7">过滤对象空属性</font></h4><p>接收对象，过滤空值属性，可忽略某些属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">filterProp</span>(<span class="params">props = &#123;&#125;, whites = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(props).reduce(<span class="function">(<span class="params">acc, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (props[key] || whites.some(<span class="function"><span class="params">value</span> =&gt;</span> value === key)) &#123;</span><br><span class="line">      acc[key] = props[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;获取值的类型&quot;&gt;&lt;a href=&quot;#获取值的类型&quot; class=&quot;headerlink&quot; title=&quot;获取值的类型&quot;&gt;&lt;/a&gt;&lt;font color=&quot;4964C7&quot;&gt;获取值的类型&lt;/font&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>总结git使用技巧</title>
    <link href="https://hao1004.github.io/2019/11/12/%E6%80%BB%E7%BB%93git%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://hao1004.github.io/2019/11/12/%E6%80%BB%E7%BB%93git%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2019-11-12T09:02:52.000Z</published>
    <updated>2019-11-19T09:15:14.744Z</updated>
    
    <content type="html"><![CDATA[<p>总结下git使用的部分技巧和心得</p><h4 id="fast-forward-和-no-fast-forward"><a href="#fast-forward-和-no-fast-forward" class="headerlink" title="fast-forward 和 no fast forward"></a><font color="4964C7">fast-forward 和 no fast forward</font></h4><p>1.A分支基于B分支，A分支在接下来的开发中提了若干commit，B分支无commit。彼时，A分支合并到B分支时，因为没有分歧需要解决，就会直接移动文件指针，合并结束后，A分支所有的commit都会直接移到B分支，就像在B分支上开发那样，这个过程叫做fast-forward</p><p>2.A分支基于B分支，A分支在接下来的开发中提了若干commit，B分支也有若干commit。彼时，A分支合并到B分支时，A分支和B分支上的commit会按照时间重新排序，并且在指针末尾添加一个“Merge branch ‘A’ into ‘B’”这样的commit，这个过程叫做no fast-forward</p><p>3.如何强行关闭fast-forward方式？在合并的时候，添加–no-ff命令，这样在上述1的情况下，也会产生一个“Merge branch ‘A’ into ‘B’”这样的commit<br><img src="/images/git/fast-forward.png" alt><br><br></p><h4 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a><font color="4964C7">merge 和 rebase</font></h4><p>git merge和git rebase都是用来合并两个分支的。</p><pre>  git merge b   // 将b分支合并到当前分支  git rebase b  // 也是把b分支合并到当前分支  git pull origin b     // 从远端拉取b分支，以merge的方式合并到当前分支  git pull -r origin b  // 从远端拉取b分支，以rebase的方式合并到当前分支</pre><p><strong>1.commit历史</strong><br><font color="e96900">merge只是合并另外一个分支的内容，rebase也合并另外一个分支的内容，但是会把本分支的commits顶到最顶端</font></p><p>场景：B分支初始有个C0提交，A分支基于B分支，A分支在9:00提交了C1、12:00提交了C2， B分支在10:00提交了C3，切换到A分支</p><p>1.运行git merge B，合并的结果C0 -&gt; C1 -&gt; C3 -&gt; C2 -&gt; Merge branch ‘B’ into ‘A’ (no fast forward模式)<br>2.运行git rebase B，合并的结果C0 -&gt; C3 -&gt; C1 -&gt; C2</p><p>rebase原理：先把A分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把A分支更新 为最新的B分支，最后把保存的这些补丁应用到A分支上</p><p><strong>2.解决冲突</strong><br>当合并分支时出现冲突</p><p>1.用merge只需要解决一遍冲突，冲突解决后，需要运行git-add 和 git-commit 相关命令<br>2.用rebase有时候会需要多次fix冲突（原因在于本地分支已经提交了非常多的commit，而且很久都没有和上游合并过），每个冲突解决之后，需要运行git-add 和 git rebase –continue，直至所有冲突解决。在任何时候，你可以用–abort参数来终止rebase的行动，使当前分支会回到rebase开始前的状态</p><p><strong>3.选用哪种合并方式</strong><br>选用merge还是rebase取决于你想以什么方式来避免冲突以及对commits的展示。两种方式都使用过，个人推荐rebase，因为commit的顺序能以一个更清晰的方式排列，另外就是频繁merge会导致的冗余的history join会提高所有人的认知成本。但使用rebase应该尽量及时rebase上游分支，如果闷头开发，提交了很多commit后再来rebase，可能出现需要多次解决冲突的情况，这会让人很头大<br><br></p><h4 id="fetch-和-pull"><a href="#fetch-和-pull" class="headerlink" title="fetch 和 pull"></a><font color="4964C7">fetch 和 pull</font></h4><p>fetch和pull都是git从远程分支拉取最新代码到本地的命令，相同点都是起到了更新代码的作用</p><pre>　git fetch orgin master  // 将远程的master分支下载到本地　git log -p              // 比较本地的master分支和远程的master分支的差别　git merge origin/master // 进行合并  git pull origin master  // 相当于git fetch 和 git merge</pre><p>只看上面的命令行，git pull 看起来像 git fetch + get merge，只是少了一个对比的过程，但是根据commit记录来看的话，他们实际的实现原理是不一样的</p><p>在了解原理之前，需要补充下部分知识<br>1.git分远程仓库和本地仓库，我们一般都是写完代码，commit到本地仓库，然后push到远程仓库，这个流程大家都熟悉<br>2.在本地我们git文件夹里面对应也存储了git本地仓库分支的commit记录 和 <font color="e96900">跟踪的远程分支的commit记录</font></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/refs/head/ <span class="string">[本地分支]</span></span><br><span class="line">.git/refs/remotes/ <span class="string">[正在跟踪的分支]</span></span><br></pre></td></tr></table></figure><p>head里存放的是我们本地正在开发中的分支记录，remotes存放的是我们本地用来跟踪远程仓库的分支记录。<font color="e96900">remotes里的跟踪分支只能用git fetch，或者是git push后作为副产品（side-effect）来改变</font> ，所以上面命令行可以这么理解</p><p>1.执行git fetch orgin master 只会更新我们跟踪远程仓库的master分支记录，此时我们本地的master分支记录是不变的，然后执行git log -p 就是在对比本地master分支和追踪master分支区别，最后执行git merge origin/master，把跟踪master分支合并到本地master分支<br>2.执行git git pull origin master，把远程master分支的拉到追踪master分支，更新记录，并直接合并到本地分支<br><img src="/images/git/git-fetch-pull.png" alt></p><p><strong>总结：</strong><br><font color="e96900">尽量不要用git pull，用git fetch和git merge代替它</font><br>使用git pull虽然便捷，但往往隐藏了合并时很多细节问题，一旦合并出了问题，排查难度也大<br>使用git fetch 和 git merge 虽然繁琐，但更加安全，能避免更多丢失及冲突问题<br><br></p><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><font color="4964C7">git stash</font></h4><p>场景：你在某个分支开发了一段时间，突然有个bug需要在该分支修复，build之后提测。这个时候你开发的东西还不能提交，怎么办？此时就可以使用git stash</p><p>git stash 就是把你的当前分支文件的修改，储存起来，推入一个储存栈中，并把文件倒退到改动前的状态。此时你就在改动前的状态下做其他修改，等修改commit到远端后，在把储存的修改放出来。</p><pre>  git stash                    // 将当前修改储存，推入栈顶  git stash list               // 查看储存栈列表  git stash apply              // 将储存栈的栈顶的修改推出  git stash apply stash@{$num} // 将储存栈里的某个修改推出 num为栈里某个存储的编号  git stash pop                // 将储存栈的栈顶的修改推出，并且删除</pre><p>需要着重说明一点<br><font color="e96900">git stash 是不会储存新增但还没add到暂存区域的文件</font><br><strong>例子：</strong>如果开发的目录本来就有个a.js文件，此时在a.js上面修改，修改后即使没有add到暂存区域里，运行git stash 修改是能被储存起来的。如果在开发目录下新增了b.js文件，在b.js上写了代码，运行git stash，b.js是不会被储存的。如果需要储存，那就要把b.js add到暂存区域，再运行git stash才能储存<br><strong>结论：</strong>被add到暂存区域的文件，一定能被git stash存储，在原本就有文件的修改，不add也能被储存，新增的文件要被储存就要先add<br><br></p><h4 id="reset-和-revert"><a href="#reset-和-revert" class="headerlink" title="reset 和 revert"></a><font color="4964C7">reset 和 revert</font></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结下git使用的部分技巧和心得&lt;/p&gt;
&lt;h4 id=&quot;fast-forward-和-no-fast-forward&quot;&gt;&lt;a href=&quot;#fast-forward-和-no-fast-forward&quot; class=&quot;headerlink&quot; title=&quot;fast-for
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于vue组件的两三事</title>
    <link href="https://hao1004.github.io/2019/09/23/%E5%85%B3%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B/"/>
    <id>https://hao1004.github.io/2019/09/23/%E5%85%B3%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B/</id>
    <published>2019-09-23T10:49:29.000Z</published>
    <updated>2019-11-12T08:51:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>总结下vue组件的相关心得</p><h4 id="vue组件的分类"><a href="#vue组件的分类" class="headerlink" title="vue组件的分类"></a><font color="4964C7">vue组件的分类</font></h4><p>vue.js 组件可以分成三类：</p><p><b>分页组件：</b>由 vue-router 产生的每个页面，本质上也是一个组件，主要承载当前页面的 HTML 结构，会包含数据获取、数据整理、数据可视化等常规业务</p><p><b>业务组件：</b>与我们项目密切相关的业务组件，主要是为了实现项目某块功能而划分的组件，基本绑定了当前项目，不具有通用性，这类组件可以再划分为两种，一种是为了被其他分页复用而的组件，一种是为了拆分逻辑的组件</p><p><b>基础组件：</b>不涉及业务，独立并拥有具体功能的组件，比如日期选择器，Toast等等，高度抽象并且能通过不同配置实现不同功能，便于多个项目使用，常见的开源组件库element-ui，iView就是这一类，因为要考虑各种功能以及通用性，该类组件是开发难度最高的<br><br></p><h4 id="vue组件的通信"><a href="#vue组件的通信" class="headerlink" title="vue组件的通信"></a><font color="4964C7">vue组件的通信</font></h4><p>vue组件间的通信方式，直接看这篇文章，总结得很全面<br>👉 <a href="https://juejin.im/post/5d267dcdf265da1b957081a3" target="_blank" rel="noopener">https://juejin.im/post/5d267dcdf265da1b957081a3</a><br><br></p><h4 id="使用mixin，扩展基础组件"><a href="#使用mixin，扩展基础组件" class="headerlink" title="使用mixin，扩展基础组件"></a><font color="4964C7">使用mixin，扩展基础组件</font></h4><p>vue的mixin（混入），官网的说法：<font color="e96900">提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项</font>。<br>其实就是提供一个可以抽取多个组件间共用选项的对象，减少重复代码，便于维护，具体的用法和规则，请点击官网👉 <a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5</a> </p><p><font color="e96900">这里主要说下mixin的另一种使用思路，利用mixin来扩展ui框架的组件。</font><br>想象下某个业务场景，需求里有个组件，跟你目前使用的ui框架的组件很相似，但又有些功能不同，或是比ui框架的多了一些逻辑判断，或是多了些扩展，这时候你会怎么办？直接改ui框架node包的源码？或者是重新写一个组件？再或者是把node包里的源码拷出来，然后再添油加醋封装成另外一个组件？有没有一种不改node依赖包的源码，但又能扩展ui框架组件的方式呢？<br>有的，就是使用mixin。方式是<font color="e96900">新建一个组件，在组件里引入node包里对应ui框架组件，然后把引入的组件作为混入对象，混入你当前的组件。然后就可以在这个新建组件下，扩展，复写原来ui组件的功能了。</font></p><pre>  &lt;script&gt;    import button from 'mint-ui/lib/button';    export default {      mixins: [button],      name: 'yx-button',      props: {        type: {          type: String,          default: 'default',          validator(value) {            return (              [                'default',                'danger',                'primary',                'common',                'warning',                'upload',                'alter'              ].indexOf(value) > -1            );          }        }      }    };    &lt;\script&gt;</pre><p>举个栗子：引入mint-ui的button组件，对type的验证加了几种类型</p><p><b>使用这种方式需要注意的一些点：</b></p><p>1.引入的node包里的文件应该尽量选择编译后的文件，我们项目babel的配置基本都是忽略node包里的文件的，如果这时候引入的组件是未编译的源码，打包上线后，就有可能出现兼容性问题</p><p>2.如果只能引入未编译的源码组件，那就需要在babel的配置上做些调整，比如单独include需要编译的依赖包。另外如果源码里使用了语法糖，如JSX，那还需要针对这块再安装相关依赖，使编译能正常进行</p><p>3.要清晰理解混入对象选项合并的方式以及优先级，具体参考👉<a href="https://cn.vuejs.org/v2/guide/mixins.html#%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/mixins.html#%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6</a></p><p>（ps: 未完待续，持续更新中…）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结下vue组件的相关心得&lt;/p&gt;
&lt;h4 id=&quot;vue组件的分类&quot;&gt;&lt;a href=&quot;#vue组件的分类&quot; class=&quot;headerlink&quot; title=&quot;vue组件的分类&quot;&gt;&lt;/a&gt;&lt;font color=&quot;4964C7&quot;&gt;vue组件的分类&lt;/font&gt;&lt;/h4&gt;
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://hao1004.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>总结使用vue开发微信公众号遇到的坑及解决方法</title>
    <link href="https://hao1004.github.io/2019/09/05/%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%E5%85%AC%E4%BC%97%E5%8F%B7%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://hao1004.github.io/2019/09/05/%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%E5%85%AC%E4%BC%97%E5%8F%B7%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2019-09-05T06:49:10.000Z</published>
    <updated>2019-09-23T10:08:23.495Z</updated>
    
    <content type="html"><![CDATA[<p>入职新公司以来，使用vue开发了一个公众号，这是第一次用vue去写移动端，踩了不少坑，主要是调微信接口以及安卓iOS两个平台兼容的问题，在这里做下总结，并附上解决方法：</p><br><h4 id="iOS不支持微信sdk并发上传图片，需要递归调用"><a href="#iOS不支持微信sdk并发上传图片，需要递归调用" class="headerlink" title="iOS不支持微信sdk并发上传图片，需要递归调用"></a>iOS不支持微信sdk并发上传图片，需要递归调用</h4><p>开发中，使用了微信sdk提供的上传图片接口<code>uploadImage</code>，因为微信本身接口的限制，调用一次只能上传一张图片，于是上传多图的时候，一开始的做法是把每次调用都封装成一个promise，最后通过promise.all实现并发上传多张图片，并统一处理返回结果的，这么实现后在安卓下是没问题的，但在iOS下就悲剧了，返回直接无响应了，后面经过了解，原因是该接口在iOS下不能并发上传，只能递归调用，也就是需要每次上传完图片后，才能接着下次调用，这里贴下递归调用的实现代码，仅供参考</p><pre>  let ids = []; //ids为选择图片接口返回的本地图片链接  let index = 0;  let imgWxUrls = [];  const upload = () => {    wxHandlerMap['uploadImage'].then(handler => {      handler({        isShowProgressTips: 0,        localId: ids[index],        success: res => {          imgWxUrls.push(res.serverId);          index ++;          if (index < ids.length) {            upload();          } else {            resolve(imgWxUrls);          }        },        fail: err => {          reject(err);        }      });    });  };  upload();</pre><br><h4 id="vue引入fastclick导致的输入框点击无响应问题（iOS）"><a href="#vue引入fastclick导致的输入框点击无响应问题（iOS）" class="headerlink" title="vue引入fastclick导致的输入框点击无响应问题（iOS）"></a>vue引入fastclick导致的输入框点击无响应问题（iOS）</h4><p>为了解决移动端点击事件300毫秒的延迟，项目引入了fastclick.js，但在iOS下，会产生输入框点击无法获取焦点的问题，只有双击或者长按的时候才能使input输入框获取到焦点，网上提供的解决方法是在FastClick.prototype.focus方法里添加一段代码<code>targetElement.focus()</code>，这里建议通过引入fastClick模块，修改了focus方法后，再引入修改后的js去修复这个问题，不要直接修改node依赖包里的代码，代码如下</p><pre>  import FastClick from 'fastclick';  var deviceIsWindowsPhone = navigator.userAgent.indexOf('Windows Phone') >= 0;  var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;  FastClick.prototype.focus = function(targetElement) {    var length;    // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {      length = targetElement.value.length;      // 添加以下一行代码      targetElement.focus();      targetElement.setSelectionRange(length, length);    } else {      targetElement.focus();    }  };  export default FastClick;</pre><br><h4 id="点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）"><a href="#点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）" class="headerlink" title="点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）"></a>点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）</h4><p>iOS下，当用户点击位于页面中部位置的input控件时，iphone键盘会弹出，此时iphone上为了让用户可以看到input控件，会将整个页面整体向上移动，但是当input失去焦点时，页面却不会自动归位，需要用户自己滑动下来才能回复原来的样子，解决方法是在失去焦点的时候，使用<code>window.scrollTo(0,0)</code>让页面归位</p><p>具体实现可以参考👉 <a href="https://segmentfault.com/a/1190000019781137?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019781137?utm_source=tag-newest</a><br><br></p><h4 id="点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）"><a href="#点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）" class="headerlink" title="点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）"></a>点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）</h4><p>安卓下，当页面存在fixed元素和input控件时，点击input控件，弹出键盘时，会导致fixed元素跟随页面上移，这样有可能导致fixed元素遮挡住了页面其他元素，造成用户体验不好，解决方法是在键盘弹起的时候，通过检测<code>document.documentElement.clientHeight</code>的数值小于页面初始高度，来决定隐藏fixed，当键盘收起的时候，再显示fixed元素，部分实现代码如下，hideBtn用在fixed元素的v-show指令</p><pre>  data() {    return {      docmHeight: document.documentElement.clientHeight,      showHeight: document.documentElement.clientHeight,      hideBtn: false    };  },  watch: {    showHeight() {      if (/(Android)/i.test(navigator.userAgent)) {        this.hideBtn = this.showHeight < this.docmHeight;      }    }  },  mounted() {    window.onresize = () => {      return (() => {        this.showHeight = document.documentElement.clientHeight;      })();    };  },  destroyed() {    window.onresize = null;  }</pre><br><h4 id="iOS下https协议页面发送不了http请求"><a href="#iOS下https协议页面发送不了http请求" class="headerlink" title="iOS下https协议页面发送不了http请求"></a>iOS下https协议页面发送不了http请求</h4><p>这个场景以前没碰到过，这次开发中，后端没把图片上传服的协议改成https，于是在ios下，用https协议的页面去发送一个http协议的ajax请求的时候，返回就变得有点奇怪了，不会报错，但status为0，这里贴下在vconsole调试下，返回的状态图，解决方法就是让后端把请求的服务器协议升级为https</p><p><img src="/images/wx-vue/1.png" alt><br><br></p><h4 id="iOS不能通过canplaythrough事件获取到audio时长的问题"><a href="#iOS不能通过canplaythrough事件获取到audio时长的问题" class="headerlink" title="iOS不能通过canplaythrough事件获取到audio时长的问题"></a>iOS不能通过canplaythrough事件获取到audio时长的问题</h4><p>audio/vidoe DOM的<code>oncanplaythrough</code>事件，定义为在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发该事件，因项目中有个录音功能，在音频节点监听这个事件，主要是为了在回调里获取录音的时长，在安卓下，是可以顺利获取录音的时长的，但在iOS下，却发现获取不了，研究了下，发现在iOS里需要音频触发播放事件后，才能获取时长，网上提供了一些解决方案，办法是通过触发一次播放，然后立即暂停音频，然后再获取时长，这种方式虽然可以解决时长获取的问题，但是在音频控件上确有一个卡顿的瞬间，体验不好，思考再三，最后还是选择iOS下将时长显示为“轻触播放”等提示语，等用户点击播放后再显示时长（ps:暂时的解决方法如上，后续继续寻找更优的做法）<br><br></p><h4 id="axios传dateForm类型的坑，用qs转化最稳妥"><a href="#axios传dateForm类型的坑，用qs转化最稳妥" class="headerlink" title="axios传dateForm类型的坑，用qs转化最稳妥"></a>axios传dateForm类型的坑，用qs转化最稳妥</h4><p>虽然大部分项目都是用vue做的，但axios这个官方推荐的ajax请求工具，却是第一次使用，之前一直是搭配其他请求工具来玩耍的，这次确实在axios上踩了点坑，主要是有部分接口，需要Form形式的数据才能正常解析，一开始的做法是修改Content-Tyoe属性</p><pre>  axios.defaults.headers = {      'Content-type': 'application/x-www-form-urlencoded'  }</pre><p>设置之后看到请求时的Content-type变成了application/x-www-form格式，但是数据没变，后面找到的办法是用qs模块的stringify方法进行转化，代码如下（ps：还是要花时间研究下axios对数据转化的源码，搞明白真正的原因）</p><pre>  import axios from './http';  import qs from 'qs';  export const uploadWxResource = (params = {}) => axios.post('https://xxxx', qs.stringify(params));</pre><br><h4 id="rem布局使用雪碧图，对图标的定位需要留空白，防止错位"><a href="#rem布局使用雪碧图，对图标的定位需要留空白，防止错位" class="headerlink" title="rem布局使用雪碧图，对图标的定位需要留空白，防止错位"></a>rem布局使用雪碧图，对图标的定位需要留空白，防止错位</h4><p>站点使用雪碧图减少图标请求数的使用，是老生常谈了，关于如何使用这里不做多叙述。主要说下rem布局中使用雪碧图，需要注意的一个细节，在给图标定位的时候，需要给四边留空白空间，如下图所示，左边是在图标的边界定位和设置大小的，这个做法在某些真机上，会有图标边界错位的问题，解决方法就是像右边那样，定位图标时，给四周留空，增大图标的面积范围。<br><font color="e96900">如果你的雪碧图是自己通过ps合成的，那就按图右边的方式去定位，如果是通过构建工具生成雪碧图的，那就处理单个图标的图片，让图标图片四周留白</font><br>ps: 更好的实现方式应该考虑svg雪碧图来实现，后续研究下</p><p><img src="/images/wx-vue/2.png" alt><br><br></p><h4 id="TypeError-Cannot-read-property-‘-wrapper’-of-undefined-这个报错一般是-click事件绑定的方法不存在导致"><a href="#TypeError-Cannot-read-property-‘-wrapper’-of-undefined-这个报错一般是-click事件绑定的方法不存在导致" class="headerlink" title="TypeError: Cannot read property ‘_wrapper’ of undefined 这个报错一般是@click事件绑定的方法不存在导致"></a>TypeError: Cannot read property ‘_wrapper’ of undefined 这个报错一般是@click事件绑定的方法不存在导致</h4><p>使用vue生态的mint-ui框架开发过程中，碰到过几次如下的报错</p><p><font color="e96900">Error in nextTick: “TypeError: Cannot read property ‘_wrapper’ of undefined”</font></p><p>这个报错的主要原因是@click事件绑定的方法，在methods中不存在导致的，但该报错不是每次都有，只在特定情况下才有，并且挺有迷惑性的，具体原因还需要后续研究下相关源码才能明了<br><br></p><h4 id="用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式"><a href="#用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式" class="headerlink" title="用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式"></a>用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式</h4><p>这是个细节问题，用html5的storage存储数据时，其实只能存字符串，所以会使用JSON对象的stringify和parse方法进行转化，一般是存入的时候用stringify转成字符串，获取数据的时候再用parse转化，这次采坑主要是存入字符串数据的时候用stringify转化了，取出的时候却没有用parse再次转化，获取到实际是’”string”‘这样的数据，咋一看还以为没问题，其实是带了双引号的字符串，排错了段时间，感觉真是被自己坑死了。这里再说一个，如果要在获取数据的时候预设一个空字符串，应该是JSON.parse(‘“”‘)，直接JSON.parse(‘’)是会报错的<br><br></p><h4 id="使用vue-keep-alive-需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数"><a href="#使用vue-keep-alive-需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数" class="headerlink" title="使用vue keep-alive 需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数"></a>使用vue keep-alive 需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数</h4><p>这也是个细节问题，使用vue的缓存组件keep-alive，会多出两个生命周期钩子activated和deactivated。缓存组件的情况下，切换组件的时候，是不会销毁组件的，组件会依旧保留在内存中，这时候如果再切换回来，需要重新获取数据，或者对某些参数初始化的话，需要在activated钩子做对应的操作。同样，离开组件的时候，如果需要解除某些绑定的事件，也需要在deactivated里做操作。<br><br></p><h4 id="预加载影响带宽性能问题"><a href="#预加载影响带宽性能问题" class="headerlink" title="预加载影响带宽性能问题"></a>预加载影响带宽性能问题</h4><p>vue-cli3默认是开启路由懒加载，并且结合link标签的preload实现预加载，预加载其他分页的资源，某种程度上可以提高用户体验，但其实内在的开销（抢占 CPU 资源，消耗电池，浪费带宽等）也是高昂的，再三考虑，最后还是决定关闭这个预加载，关闭的配置很简单，如下</p><pre>  chainWebpack: config => { config.plugins.delete('prefetch'); }</pre> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入职新公司以来，使用vue开发了一个公众号，这是第一次用vue去写移动端，踩了不少坑，主要是调微信接口以及安卓iOS两个平台兼容的问题，在这里做下总结，并附上解决方法：&lt;/p&gt;
&lt;br&gt;

&lt;h4 id=&quot;iOS不支持微信sdk并发上传图片，需要递归调用&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://hao1004.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
