<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨俊浩的个人主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hao1004.github.io/"/>
  <updated>2019-11-15T10:27:02.225Z</updated>
  <id>https://hao1004.github.io/</id>
  
  <author>
    <name>杨俊浩</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>总结git使用技巧</title>
    <link href="https://hao1004.github.io/2019/11/12/%E6%80%BB%E7%BB%93git%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://hao1004.github.io/2019/11/12/总结git使用技巧/</id>
    <published>2019-11-12T09:02:52.000Z</published>
    <updated>2019-11-15T10:27:02.225Z</updated>
    
    <content type="html"><![CDATA[<p>总结下git使用的部分技巧和心得</p><h4 id="fast-forward-和-no-fast-forward"><a href="#fast-forward-和-no-fast-forward" class="headerlink" title="fast-forward 和 no fast forward"></a><font color="4964C7">fast-forward 和 no fast forward</font></h4><p>1.A分支基于B分支，A分支在接下来的开发中提了若干commit，B分支无commit。彼时，A分支合并到B分支时，因为没有分歧需要解决，就会直接移动文件指针，合并结束后，A分支所有的commit都会直接移到B分支，就像在B分支上开发那样，这个过程叫做fast-forward</p><p>2.A分支基于B分支，A分支在接下来的开发中提了若干commit，B分支也有若干commit。彼时，A分支合并到B分支时，A分支和B分支上的commit会按照时间重新排序，并且在指针末尾添加一个“Merge branch ‘A’ into ‘B’”这样的commit，这个过程叫做no fast-forward</p><p>3.如何强行关闭fast-forward方式？在合并的时候，添加–no-ff命令，这样在上述1的情况下，也会产生一个“Merge branch ‘A’ into ‘B’”这样的commit<br><img src="/images/git/fast-forward.png" alt><br><br></p><h4 id="merge-和-rebase"><a href="#merge-和-rebase" class="headerlink" title="merge 和 rebase"></a><font color="4964C7">merge 和 rebase</font></h4><p>git merge和git rebase都是用来合并两个分支的。</p><pre>  git merge b   // 将b分支合并到当前分支  git rebase b  // 也是把b分支合并到当前分支  git pull origin b     // 从远端拉取b分支，以merge的方式合并到当前分支  git pull -r origin b  // 从远端拉取b分支，以rebase的方式合并到当前分支</pre><p><strong>1.commit历史</strong><br><font color="e96900">merge只是合并另外一个分支的内容，rebase也合并另外一个分支的内容，但是会把本分支的commits顶到最顶端</font></p><p>场景：B分支初始有个C0提交，A分支基于B分支，A分支在9:00提交了C1、12:00提交了C2， B分支在10:00提交了C3，切换到A分支</p><p>1.运行git merge B，合并的结果C0 -&gt; C1 -&gt; C3 -&gt; C2 -&gt; Merge branch ‘B’ into ‘A’ (no fast forward模式)<br>2.运行git rebase B，合并的结果C0 -&gt; C3 -&gt; C1 -&gt; C2</p><p>rebase原理：先把A分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”.git/rebase”目录中),然后把A分支更新 为最新的B分支，最后把保存的这些补丁应用到A分支上</p><p><strong>2.解决冲突</strong><br>当合并分支时出现冲突</p><p>1.用merge只需要解决一遍冲突，冲突解决后，需要运行git-add 和 git-commit 相关命令<br>2.用rebase有时候会需要多次fix冲突（原因在于本地分支已经提交了非常多的commit，而且很久都没有和上游合并过），每个冲突解决之后，需要运行git-add 和 git rebase –continue，直至所有冲突解决。在任何时候，你可以用–abort参数来终止rebase的行动，使当前分支会回到rebase开始前的状态</p><p><strong>3.选用哪种合并方式</strong><br>选用merge还是rebase取决于你想以什么方式来避免冲突以及对commits的展示。两种方式都使用过，个人推荐rebase，因为commit的顺序能以一个更清晰的方式排列，另外就是频繁merge会导致的冗余的history join会提高所有人的认知成本。但使用rebase应该尽量及时rebase上游分支，如果闷头开发，提交了很多commit后再来rebase，可能出现需要多次解决冲突的情况，这会让人很头大<br><br></p><h4 id="fetch-和-pull"><a href="#fetch-和-pull" class="headerlink" title="fetch 和 pull"></a><font color="4964C7">fetch 和 pull</font></h4><p>fetch和pull都是git从远程分支拉取最新代码到本地的命令，相同点都是起到了更新代码的作用</p><pre>　git fetch orgin master  // 将远程的master分支下载到本地　git log -p              // 比较本地的master分支和远程的master分支的差别　git merge origin/master // 进行合并  git pull origin master  // 相当于git fetch 和 git merge</pre><p>只看上面的命令行，git pull 看起来像 git fetch + get merge，只是少了一个对比的过程，但是根据commit记录来看的话，他们实际的实现原理是不一样的</p><p>在了解原理之前，需要补充下部分知识<br>1.git分远程仓库和本地仓库，我们一般都是写完代码，commit到本地仓库，然后push到远程仓库，这个流程大家都熟悉<br>2.在本地我们git文件夹里面对应也存储了git本地仓库分支的commit记录 和 <font color="e96900">跟踪的远程分支的commit记录</font></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/refs/head/ <span class="string">[本地分支]</span></span><br><span class="line">.git/refs/remotes/ <span class="string">[正在跟踪的分支]</span></span><br></pre></td></tr></table></figure><p>head里存放的是我们本地正在开发中的分支记录，remotes存放的是我们本地用来跟踪远程仓库的分支记录。<font color="e96900">remotes里的跟踪分支只能用git fetch，或者是git push后作为副产品（side-effect）来改变</font> ，所以上面命令行可以这么理解</p><p>1.执行git fetch orgin master 只会更新我们跟踪远程仓库的master分支记录，此时我们本地的master分支记录是不变的，然后执行git log -p 就是在对比本地master分支和追踪master分支区别，最后执行git merge origin/master，把跟踪master分支合并到本地master分支<br>2.执行git git pull origin master，把远程master分支的拉到追踪master分支，更新记录，并直接合并到本地分支<br><img src="/images/git/git-fetch-pull.png" alt></p><p><strong>总结：</strong><br><font color="e96900">尽量不要用git pull，用git fetch和git merge代替它</font><br>使用git pull虽然便捷，但往往隐藏了合并时很多细节问题，一旦合并出了问题，排查难度也大<br>使用git fetch 和 git merge 虽然繁琐，但更加安全，能避免更多丢失及冲突问题<br><br></p><h4 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><font color="4964C7">git stash</font></h4><p>场景：你在某个分支开发了一段时间，突然有个bug需要在该分支修复，build之后提测。这个时候你开发的东西还不能提交，怎么办？此时就可以使用git stash</p><p>git stash 就是把你的当前分支文件的修改，储存起来，推入一个储存栈中，并把文件倒退到改动前的状态。此时你就在改动前的状态下做其他修改，等修改commit到远端后，在把储存的修改放出来。</p><pre>  git stash                    // 将当前修改储存，推入栈顶  git stash list               // 查看储存栈列表  git stash apply              // 将储存栈的栈顶的修改推出  git stash apply stash@{$num} // 将储存栈里的某个修改推出 num为栈里某个存储的编号  git stash pop                // 将储存栈的栈顶的修改推出，并且删除</pre><p>需要着重说明一点<br><font color="e96900">git stash 是不会储存新增但还没暂存到版本控制的文件</font><br><strong>例子：</strong>如果开发的目录本来就有个a.js文件，此时在a.js上面修改，修改后即使没有add到版本控制里，运行git stash 修改是能被储存起来的。如果在开发目录下新增了b.js文件，在b.js上写了代码，运行git stash，b.js是不会被储存的。如果需要储存，那就要把b.js add到版本控制，再运行git stash才能储存<br><strong>结论：</strong>被add到版本控制的文件，一定能被git stash存储，在原本就有文件的修改，不add也能被储存，新增的文件要被储存就要先add<br><br></p><h4 id="reset-和-revert"><a href="#reset-和-revert" class="headerlink" title="reset 和 revert"></a><font color="4964C7">reset 和 revert</font></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结下git使用的部分技巧和心得&lt;/p&gt;
&lt;h4 id=&quot;fast-forward-和-no-fast-forward&quot;&gt;&lt;a href=&quot;#fast-forward-和-no-fast-forward&quot; class=&quot;headerlink&quot; title=&quot;fast-for
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于vue组件的两三事</title>
    <link href="https://hao1004.github.io/2019/09/23/%E5%85%B3%E4%BA%8Evue%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B/"/>
    <id>https://hao1004.github.io/2019/09/23/关于vue组件的两三事/</id>
    <published>2019-09-23T10:49:29.000Z</published>
    <updated>2019-11-12T08:51:10.354Z</updated>
    
    <content type="html"><![CDATA[<p>总结下vue组件的相关心得</p><h4 id="vue组件的分类"><a href="#vue组件的分类" class="headerlink" title="vue组件的分类"></a><font color="4964C7">vue组件的分类</font></h4><p>vue.js 组件可以分成三类：</p><p><b>分页组件：</b>由 vue-router 产生的每个页面，本质上也是一个组件，主要承载当前页面的 HTML 结构，会包含数据获取、数据整理、数据可视化等常规业务</p><p><b>业务组件：</b>与我们项目密切相关的业务组件，主要是为了实现项目某块功能而划分的组件，基本绑定了当前项目，不具有通用性，这类组件可以再划分为两种，一种是为了被其他分页复用而的组件，一种是为了拆分逻辑的组件</p><p><b>基础组件：</b>不涉及业务，独立并拥有具体功能的组件，比如日期选择器，Toast等等，高度抽象并且能通过不同配置实现不同功能，便于多个项目使用，常见的开源组件库element-ui，iView就是这一类，因为要考虑各种功能以及通用性，该类组件是开发难度最高的<br><br></p><h4 id="vue组件的通信"><a href="#vue组件的通信" class="headerlink" title="vue组件的通信"></a><font color="4964C7">vue组件的通信</font></h4><p>vue组件间的通信方式，直接看这篇文章，总结得很全面<br>👉 <a href="https://juejin.im/post/5d267dcdf265da1b957081a3" target="_blank" rel="noopener">https://juejin.im/post/5d267dcdf265da1b957081a3</a><br><br></p><h4 id="使用mixin，扩展基础组件"><a href="#使用mixin，扩展基础组件" class="headerlink" title="使用mixin，扩展基础组件"></a><font color="4964C7">使用mixin，扩展基础组件</font></h4><p>vue的mixin（混入），官网的说法：<font color="e96900">提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项</font>。<br>其实就是提供一个可以抽取多个组件间共用选项的对象，减少重复代码，便于维护，具体的用法和规则，请点击官网👉 <a href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/mixins.html#%E5%85%A8%E5%B1%80%E6%B7%B7%E5%85%A5</a> </p><p><font color="e96900">这里主要说下mixin的另一种使用思路，利用mixin来扩展ui框架的组件。</font><br>想象下某个业务场景，需求里有个组件，跟你目前使用的ui框架的组件很相似，但又有些功能不同，或是比ui框架的多了一些逻辑判断，或是多了些扩展，这时候你会怎么办？直接改ui框架node包的源码？或者是重新写一个组件？再或者是把node包里的源码拷出来，然后再添油加醋封装成另外一个组件？有没有一种不改node依赖包的源码，但又能扩展ui框架组件的方式呢？<br>有的，就是使用mixin。方式是<font color="e96900">新建一个组件，在组件里引入node包里对应ui框架组件，然后把引入的组件作为混入对象，混入你当前的组件。然后就可以在这个新建组件下，扩展，复写原来ui组件的功能了。</font></p><pre>  &lt;script&gt;    import button from 'mint-ui/lib/button';    export default {      mixins: [button],      name: 'yx-button',      props: {        type: {          type: String,          default: 'default',          validator(value) {            return (              [                'default',                'danger',                'primary',                'common',                'warning',                'upload',                'alter'              ].indexOf(value) > -1            );          }        }      }    };    &lt;\script&gt;</pre><p>举个栗子：引入mint-ui的button组件，对type的验证加了几种类型</p><p><b>使用这种方式需要注意的一些点：</b></p><p>1.引入的node包里的文件应该尽量选择编译后的文件，我们项目babel的配置基本都是忽略node包里的文件的，如果这时候引入的组件是未编译的源码，打包上线后，就有可能出现兼容性问题</p><p>2.如果只能引入未编译的源码组件，那就需要在babel的配置上做些调整，比如单独include需要编译的依赖包。另外如果源码里使用了语法糖，如JSX，那还需要针对这块再安装相关依赖，使编译能正常进行</p><p>3.要清晰理解混入对象选项合并的方式以及优先级，具体参考👉<a href="https://cn.vuejs.org/v2/guide/mixins.html#%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/mixins.html#%E9%80%89%E9%A1%B9%E5%90%88%E5%B9%B6</a></p><p>（ps: 未完待续，持续更新中…）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结下vue组件的相关心得&lt;/p&gt;
&lt;h4 id=&quot;vue组件的分类&quot;&gt;&lt;a href=&quot;#vue组件的分类&quot; class=&quot;headerlink&quot; title=&quot;vue组件的分类&quot;&gt;&lt;/a&gt;&lt;font color=&quot;4964C7&quot;&gt;vue组件的分类&lt;/font&gt;&lt;/h4&gt;
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://hao1004.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>总结使用vue开发微信公众号遇到的坑及解决方法</title>
    <link href="https://hao1004.github.io/2019/09/05/%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8vue%E5%BC%80%E5%8F%91%E5%85%AC%E4%BC%97%E5%8F%B7%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://hao1004.github.io/2019/09/05/总结使用vue开发公众号遇到的坑及解决方法/</id>
    <published>2019-09-05T06:49:10.000Z</published>
    <updated>2019-09-23T10:08:23.495Z</updated>
    
    <content type="html"><![CDATA[<p>入职新公司以来，使用vue开发了一个公众号，这是第一次用vue去写移动端，踩了不少坑，主要是调微信接口以及安卓iOS两个平台兼容的问题，在这里做下总结，并附上解决方法：</p><br><h4 id="iOS不支持微信sdk并发上传图片，需要递归调用"><a href="#iOS不支持微信sdk并发上传图片，需要递归调用" class="headerlink" title="iOS不支持微信sdk并发上传图片，需要递归调用"></a>iOS不支持微信sdk并发上传图片，需要递归调用</h4><p>开发中，使用了微信sdk提供的上传图片接口<code>uploadImage</code>，因为微信本身接口的限制，调用一次只能上传一张图片，于是上传多图的时候，一开始的做法是把每次调用都封装成一个promise，最后通过promise.all实现并发上传多张图片，并统一处理返回结果的，这么实现后在安卓下是没问题的，但在iOS下就悲剧了，返回直接无响应了，后面经过了解，原因是该接口在iOS下不能并发上传，只能递归调用，也就是需要每次上传完图片后，才能接着下次调用，这里贴下递归调用的实现代码，仅供参考</p><pre>  let ids = []; //ids为选择图片接口返回的本地图片链接  let index = 0;  let imgWxUrls = [];  const upload = () => {    wxHandlerMap['uploadImage'].then(handler => {      handler({        isShowProgressTips: 0,        localId: ids[index],        success: res => {          imgWxUrls.push(res.serverId);          index ++;          if (index < ids.length) {            upload();          } else {            resolve(imgWxUrls);          }        },        fail: err => {          reject(err);        }      });    });  };  upload();</pre><br><h4 id="vue引入fastclick导致的输入框点击无响应问题（iOS）"><a href="#vue引入fastclick导致的输入框点击无响应问题（iOS）" class="headerlink" title="vue引入fastclick导致的输入框点击无响应问题（iOS）"></a>vue引入fastclick导致的输入框点击无响应问题（iOS）</h4><p>为了解决移动端点击事件300毫秒的延迟，项目引入了fastclick.js，但在iOS下，会产生输入框点击无法获取焦点的问题，只有双击或者长按的时候才能使input输入框获取到焦点，网上提供的解决方法是在FastClick.prototype.focus方法里添加一段代码<code>targetElement.focus()</code>，这里建议通过引入fastClick模块，修改了focus方法后，再引入修改后的js去修复这个问题，不要直接修改node依赖包里的代码，代码如下</p><pre>  import FastClick from 'fastclick';  var deviceIsWindowsPhone = navigator.userAgent.indexOf('Windows Phone') >= 0;  var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;  FastClick.prototype.focus = function(targetElement) {    var length;    // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {      length = targetElement.value.length;      // 添加以下一行代码      targetElement.focus();      targetElement.setSelectionRange(length, length);    } else {      targetElement.focus();    }  };  export default FastClick;</pre><br><h4 id="点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）"><a href="#点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）" class="headerlink" title="点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）"></a>点击页面中部input，输入后收起键盘，页面上移不归位的问题（iOS）</h4><p>iOS下，当用户点击位于页面中部位置的input控件时，iphone键盘会弹出，此时iphone上为了让用户可以看到input控件，会将整个页面整体向上移动，但是当input失去焦点时，页面却不会自动归位，需要用户自己滑动下来才能回复原来的样子，解决方法是在失去焦点的时候，使用<code>window.scrollTo(0,0)</code>让页面归位</p><p>具体实现可以参考👉 <a href="https://segmentfault.com/a/1190000019781137?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019781137?utm_source=tag-newest</a><br><br></p><h4 id="点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）"><a href="#点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）" class="headerlink" title="点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）"></a>点击input，fixed元素跟随键盘上移，收回键盘后，页面错位的问题（安卓）</h4><p>安卓下，当页面存在fixed元素和input控件时，点击input控件，弹出键盘时，会导致fixed元素跟随页面上移，这样有可能导致fixed元素遮挡住了页面其他元素，造成用户体验不好，解决方法是在键盘弹起的时候，通过检测<code>document.documentElement.clientHeight</code>的数值小于页面初始高度，来决定隐藏fixed，当键盘收起的时候，再显示fixed元素，部分实现代码如下，hideBtn用在fixed元素的v-show指令</p><pre>  data() {    return {      docmHeight: document.documentElement.clientHeight,      showHeight: document.documentElement.clientHeight,      hideBtn: false    };  },  watch: {    showHeight() {      if (/(Android)/i.test(navigator.userAgent)) {        this.hideBtn = this.showHeight < this.docmHeight;      }    }  },  mounted() {    window.onresize = () => {      return (() => {        this.showHeight = document.documentElement.clientHeight;      })();    };  },  destroyed() {    window.onresize = null;  }</pre><br><h4 id="iOS下https协议页面发送不了http请求"><a href="#iOS下https协议页面发送不了http请求" class="headerlink" title="iOS下https协议页面发送不了http请求"></a>iOS下https协议页面发送不了http请求</h4><p>这个场景以前没碰到过，这次开发中，后端没把图片上传服的协议改成https，于是在ios下，用https协议的页面去发送一个http协议的ajax请求的时候，返回就变得有点奇怪了，不会报错，但status为0，这里贴下在vconsole调试下，返回的状态图，解决方法就是让后端把请求的服务器协议升级为https</p><p><img src="/images/wx-vue/1.png" alt><br><br></p><h4 id="iOS不能通过canplaythrough事件获取到audio时长的问题"><a href="#iOS不能通过canplaythrough事件获取到audio时长的问题" class="headerlink" title="iOS不能通过canplaythrough事件获取到audio时长的问题"></a>iOS不能通过canplaythrough事件获取到audio时长的问题</h4><p>audio/vidoe DOM的<code>oncanplaythrough</code>事件，定义为在视频/音频（audio/video）可以正常播放且无需停顿和缓冲时触发该事件，因项目中有个录音功能，在音频节点监听这个事件，主要是为了在回调里获取录音的时长，在安卓下，是可以顺利获取录音的时长的，但在iOS下，却发现获取不了，研究了下，发现在iOS里需要音频触发播放事件后，才能获取时长，网上提供了一些解决方案，办法是通过触发一次播放，然后立即暂停音频，然后再获取时长，这种方式虽然可以解决时长获取的问题，但是在音频控件上确有一个卡顿的瞬间，体验不好，思考再三，最后还是选择iOS下将时长显示为“轻触播放”等提示语，等用户点击播放后再显示时长（ps:暂时的解决方法如上，后续继续寻找更优的做法）<br><br></p><h4 id="axios传dateForm类型的坑，用qs转化最稳妥"><a href="#axios传dateForm类型的坑，用qs转化最稳妥" class="headerlink" title="axios传dateForm类型的坑，用qs转化最稳妥"></a>axios传dateForm类型的坑，用qs转化最稳妥</h4><p>虽然大部分项目都是用vue做的，但axios这个官方推荐的ajax请求工具，却是第一次使用，之前一直是搭配其他请求工具来玩耍的，这次确实在axios上踩了点坑，主要是有部分接口，需要Form形式的数据才能正常解析，一开始的做法是修改Content-Tyoe属性</p><pre>  axios.defaults.headers = {      'Content-type': 'application/x-www-form-urlencoded'  }</pre><p>设置之后看到请求时的Content-type变成了application/x-www-form格式，但是数据没变，后面找到的办法是用qs模块的stringify方法进行转化，代码如下（ps：还是要花时间研究下axios对数据转化的源码，搞明白真正的原因）</p><pre>  import axios from './http';  import qs from 'qs';  export const uploadWxResource = (params = {}) => axios.post('https://xxxx', qs.stringify(params));</pre><br><h4 id="rem布局使用雪碧图，对图标的定位需要留空白，防止错位"><a href="#rem布局使用雪碧图，对图标的定位需要留空白，防止错位" class="headerlink" title="rem布局使用雪碧图，对图标的定位需要留空白，防止错位"></a>rem布局使用雪碧图，对图标的定位需要留空白，防止错位</h4><p>站点使用雪碧图减少图标请求数的使用，是老生常谈了，关于如何使用这里不做多叙述。主要说下rem布局中使用雪碧图，需要注意的一个细节，在给图标定位的时候，需要给四边留空白空间，如下图所示，左边是在图标的边界定位和设置大小的，这个做法在某些真机上，会有图标边界错位的问题，解决方法就是像右边那样，定位图标时，给四周留空，增大图标的面积范围。<br><font color="e96900">如果你的雪碧图是自己通过ps合成的，那就按图右边的方式去定位，如果是通过构建工具生成雪碧图的，那就处理单个图标的图片，让图标图片四周留白</font><br>ps: 更好的实现方式应该考虑svg雪碧图来实现，后续研究下</p><p><img src="/images/wx-vue/2.png" alt><br><br></p><h4 id="TypeError-Cannot-read-property-‘-wrapper’-of-undefined-这个报错一般是-click事件绑定的方法不存在导致"><a href="#TypeError-Cannot-read-property-‘-wrapper’-of-undefined-这个报错一般是-click事件绑定的方法不存在导致" class="headerlink" title="TypeError: Cannot read property ‘_wrapper’ of undefined 这个报错一般是@click事件绑定的方法不存在导致"></a>TypeError: Cannot read property ‘_wrapper’ of undefined 这个报错一般是@click事件绑定的方法不存在导致</h4><p>使用vue生态的mint-ui框架开发过程中，碰到过几次如下的报错</p><p><font color="e96900">Error in nextTick: “TypeError: Cannot read property ‘_wrapper’ of undefined”</font></p><p>这个报错的主要原因是@click事件绑定的方法，在methods中不存在导致的，但该报错不是每次都有，只在特定情况下才有，并且挺有迷惑性的，具体原因还需要后续研究下相关源码才能明了<br><br></p><h4 id="用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式"><a href="#用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式" class="headerlink" title="用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式"></a>用storage存储数据，应该严格使用JSON对象进行转化，避免获取到错误的数据格式</h4><p>这是个细节问题，用html5的storage存储数据时，其实只能存字符串，所以会使用JSON对象的stringify和parse方法进行转化，一般是存入的时候用stringify转成字符串，获取数据的时候再用parse转化，这次采坑主要是存入字符串数据的时候用stringify转化了，取出的时候却没有用parse再次转化，获取到实际是’”string”‘这样的数据，咋一看还以为没问题，其实是带了双引号的字符串，排错了段时间，感觉真是被自己坑死了。这里再说一个，如果要在获取数据的时候预设一个空字符串，应该是JSON.parse(‘“”‘)，直接JSON.parse(‘’)是会报错的<br><br></p><h4 id="使用vue-keep-alive-需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数"><a href="#使用vue-keep-alive-需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数" class="headerlink" title="使用vue keep-alive 需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数"></a>使用vue keep-alive 需要注意在离开组件时，对绑定的事件进行解除，以及重新进入时是否需要重新初始化参数</h4><p>这也是个细节问题，使用vue的缓存组件keep-alive，会多出两个生命周期钩子activated和deactivated。缓存组件的情况下，切换组件的时候，是不会销毁组件的，组件会依旧保留在内存中，这时候如果再切换回来，需要重新获取数据，或者对某些参数初始化的话，需要在activated钩子做对应的操作。同样，离开组件的时候，如果需要解除某些绑定的事件，也需要在deactivated里做操作。<br><br></p><h4 id="预加载影响带宽性能问题"><a href="#预加载影响带宽性能问题" class="headerlink" title="预加载影响带宽性能问题"></a>预加载影响带宽性能问题</h4><p>vue-cli3默认是开启路由懒加载，并且结合link标签的preload实现预加载，预加载其他分页的资源，某种程度上可以提高用户体验，但其实内在的开销（抢占 CPU 资源，消耗电池，浪费带宽等）也是高昂的，再三考虑，最后还是决定关闭这个预加载，关闭的配置很简单，如下</p><pre>  chainWebpack: config => { config.plugins.delete('prefetch'); }</pre> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入职新公司以来，使用vue开发了一个公众号，这是第一次用vue去写移动端，踩了不少坑，主要是调微信接口以及安卓iOS两个平台兼容的问题，在这里做下总结，并附上解决方法：&lt;/p&gt;
&lt;br&gt;

&lt;h4 id=&quot;iOS不支持微信sdk并发上传图片，需要递归调用&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
      <category term="vue" scheme="https://hao1004.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
